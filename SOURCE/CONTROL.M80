$title  ('Control routines')
        name    Control

        cseg


        public Ctrl__init
        public Ctrl_Close


        public Ctrl_DelMenuKeyb
        public Ctrl_SetMenuKeyb

        public Ctrl_Get
        public Ctrl_GetCustom
        public Ctrl_PressAnyKey
        public Ctrl_ReadKey


        public Ctrl_SetVector
        public Ctrl_DelVector


        public Timer_ticks
        public Ctrl_KeyUp
        public Ctrl_KeyLeft
        public Ctrl_KeyRight
        public Ctrl_KeyDown


        public Abs


AUTOTIME        equ 50/5        ; задержка включения автоповтора
AUTOSPD         equ 5           ; скорость автоповтора = (50 / AUTOSPD) нажатий в секунду



INTMGR  equ 0FEDCh      ; адрес менеджера IRQ
INTJMP  equ 0F86Eh      ; переход на пользовательский обработчик прерывания
INTADR  equ 0F86Fh      ; адрес пользовательского обработчика




;------------------------------------------------------------------------
; получение абсолютного значения числа
;------------------------------------------------------------------------
Abs:
        mov     A, C
        ana     A
        rp
        cma
        inr     A
        ret



;------------------------------------------------------------------------
; Инициализация системы IRQ
;------------------------------------------------------------------------
Ctrl__init:
        ; делаем доступной всю память
        mvi     A, 0FFh
        out     80h
        ; переносим обработчик в верхние адреса
        lxi     D, IrqManager
        lxi     H, INTMGR
        mvi     C, IrqMngEnd-IrqManager
    @sirql:
        ldax    D
        mov     M, A
        inx     D
        inx     H
        dcr     C
        jnz     @sirql
        ; сохраняем старый
        lda     INTJMP
        sta     OldVecJmp
        lhld    INTADR
        shld    OldVecAddr
        ; ставим свой
        di
        mvi     A, 0C3h         ; jmp
        sta     INTJMP
        lxi     H, INTMGR
        shld    INTADR
        ei
        ; ставим дефолтные значения для кнопок
        lxi     H, Ctrl_KeyUp
        mvi     M, 0C5h
        lxi     H, Ctrl_KeyLeft
        mvi     M, 0C4h
        lxi     H, Ctrl_KeyRight
        mvi     M, 0C7h
        lxi     H, Ctrl_KeyDown
        mvi     M, 0C6h
        ret

;------------------------------------------------------------------------
; Удаление своей системы IRQ
;------------------------------------------------------------------------
Ctrl_Close:
        di
        lda     OldVecJmp
        sta     INTJMP
        lhld    OldVecAddr
        shld    INTADR
        ; очищаем очередь клавиатуры BIOS от случайных значений
        lxi     H, 0FB85h
        shld    0FA2Ch
        shld    0FA2Ah
        ei
        ret

;------------------------------------------------------------------------
; Установка нового вектора прерывания
;------------------------------------------------------------------------
; на входе:
;    BC - адрес нового вектора
;    DE - адрес для сохранения перехода на старый вектор (3 байта)
Ctrl_SetVector:
        di
        ; сохраняем старый вектор
        push    B
        lxi     H, UserVectors
        mvi     C, 3
    @svecs:
        mov     A, M
        stax    D
        inx     H
        inx     D
        dcr     C
        jnz     @svecs
        ; устанавливаем новый
        pop     H
        mvi     A, 0C3h
        sta     UserVectors
        shld    UserVectors+1
        ei
        ret

;------------------------------------------------------------------------
; Удаление последнего вектора
;------------------------------------------------------------------------
; на входе:
;    BC - адрес сохраненного вектора
Ctrl_DelVector:
        di
        lxi     H, UserVectors
        mvi     E, 3
    @dvecr:
        ldax    B
        mov     M, A
        inx     B
        inx     H
        dcr     E
        jnz     @dvecr
        ei
        ret



;------------------------------------------------------------------------
; Менеджер пользовательских прерываний, вызывается из ПЗУ
; при каждом прерывании
;------------------------------------------------------------------------
IrqManager:
        ; убираем из стека адрес возврата в функцию BIOS,
        ; теперь по RET будет выход из обработчика IRQ, пропустив
        ; код обработчика BIOS
        xthl
        pop     H
        ; сохраняем состояние регистров
        push    H
        push    D
        push    B
        push    PSW
        ; делаем доступной всю память
        in      80h
        push    PSW
        mvi     A, 0FFh
        out     80h
        ; тикаем счётчик таймера
        lxi     H, Timer_ticks
        inr     M
        ; вызываем цепочку обработчиков прерывания
        call    UserVectors     ; вызов пользовательских подпрограмм
        ; восстанавливаем окна памяти
        pop     PSW
        out     80h
        pop     PSW
        pop     B
        pop     D
        pop     H
        ei
        ret
IrqMngEnd:

UserVectors:
        ret
        ret
        ret



;*****************************************************************************
;                                 КЛАВИАТУРА
;*****************************************************************************

;------------------------------------------------------------------------
; Удаление буферезированного ввода,
; для перехода на прямое чтение клавиатуры
;------------------------------------------------------------------------

Ctrl_DelMenuKeyb:
        ; ждем отпускания всех клавиш
        lda     fPressed
        mov     C, A
        lda     fShift
        ora     C
        jnz     Ctrl_DelMenuKeyb
        ; снимаем обработчик
        lxi     B, OLDISR
        call    Ctrl_DelVector
        ret


;------------------------------------------------------------------------
; Установка буферезированного ввода с клавиатуры
;------------------------------------------------------------------------
Ctrl_SetMenuKeyb:
        lxi     H, keyBuffer
        shld    ptrBufFirst
        shld    ptrBufLast
        ; и флаги
        xra     A
        sta     fPressed
        sta     fShift

        ; устанавливаем обработчик прерывания
        lxi     B, Ctrl_KeyISR
        lxi     D, OLDISR
        call    Ctrl_SetVector
        ret


;------------------------------------------------------------------------
; возвращает скан-код нажатой клавиши
;------------------------------------------------------------------------
Ctrl_Get:
Ctrl_GetCustom:
        ; сканируем всю матрицу
        mvi     C, 9
  kbc_kbScanLoop:
        mov     A, C
        call    kbColumn
        ora     A
        jnz     kbc_kbFound
    kbc_kbNext:
        dcr     C
        jp      kbc_kbScanLoop
        xra     A
        ret
    kbc_kbFound:                ; что-то нажали
        ; выделяем крайний справа бит = x & (-x)
        mov     B, A
        cma
        inr     A
        ana     B
        rz                      ; что-то пошло не так
        ; A -  маска
        ; C - ряд матрицы
        mvi     B, 0
    kbc_cbclp:
        rrc
        jc      kbc_cbcdn
        inr     B
        jmp     kbc_cbclp
    kbc_cbcdn:
        mov     A, C
        ani     0Fh
        rlc
        rlc
        rlc
        add     B               ; A = column * 8 + (номер бита строки)

        ; теперь переводим сканкод в символьный вид
        mov     L, A            ; HL - скан-код клавиши
        mvi     H, 0
        lxi     D, tabXlat
        dad     D
        ; возвращаем скан-код клавиши
        mov     A, M            ; A - символьный код клавиши
        ret

;------------------------------------------------------------------------
; чтение строки клавиатурной матрицы
;------------------------------------------------------------------------
; на входе:
;    A  - номер строки матрицы [0..9]
; на выходе:
;    A  - строка (единичные биты - нажатые клавиши)
;    C  - номер строки матрицы [0..9]
kbColumn:
        ani     0Fh
        mov     C, A
        in      82h
        ani     0F0h
        ora     C
        out     82h
        in      81h
        cma
        ret


;------------------------------------------------------------------------
; проверяет наличие кода в буфере клавиатуры
;------------------------------------------------------------------------
; на выходе:
;    A  - 0: буфер пуст, A: есть символ в буфере
Ctrl_PressAnyKey:
        lhld    ptrBufLast
        xchg
        lhld    ptrBufFirst
        call    CompareWord
        mvi     A, 0
        rz
        inr     A
        ret

;------------------------------------------------------------------------
; сравнение двух 16-битных слов HL и DE
;------------------------------------------------------------------------
; на выходе: флаги как при сравнении 8-битных данных
CompareWord:
        mov     A, H            ; сравниваем старшие байты
        sub     D
        rnz                     ; if (z==0) exit
        mov     A, L            ; сравниваем младшие байты
        sub     E
        ret



;------------------------------------------------------------------------
; чтение символа с клавиатуры с ожиданием
;------------------------------------------------------------------------
; на выходе:
;    A  - символьный вид нажатой клавиши
Ctrl_ReadKey:
        call    Ctrl_PressAnyKey
        ora     A
        jz      Ctrl_ReadKey
        lhld    ptrBufFirst
        mov     B, M
        inx     H
        lxi     D, endBuffer
        call    CompareWord
        di
        jnz     @gtchd
        lxi     H, keyBuffer
    @gtchd:
        shld    ptrBufFirst
        mov     A, B
        ei
        ret

;;------------------------------------------------------------------------
;; Обработчик прерывания - сканер матрицы клавиатуры
;;------------------------------------------------------------------------
Ctrl_KeyISR:
        ; сначала обновляем состояние клавиши 'РГ'
        mvi     A, 6
        call    kbColumn
        ani     01h
        sta     fShift
        ; теперь проверяем на предмет автоповтора
        lda     fPressed
        ora     A
        jnz     @kbRepeat
        ; нет нажатых клавиш, сканируем всю матрицу
        mvi     C, 0
  @kbScanLoop:
        mov     A, C
        cpi     10
        jnc     OLDISR          ; ничего не нашли, уходим
        call    kbColumn
        ora     A
        jnz     @kbFound
    @kbNext:
        inr     C
        jmp     @kbScanLoop
    @kbFound:   ; что-то нажали
        ; сначала проверяем, не был ли это РГ?
        mov     B, A
        mov     A, C
        cpi     6
        jnz     @kbStore
        mov     A, B
        ani     0FEh
        jz      @kbNext         ; это был только РГ, продолжаем поиск
    @kbStore:
        ; выделяем крайний справа бит = x & (-x)
        mov     A, B
        cma
        inr     A
        ana     B
        ; и сохраняем полученную маску для выделения этого бита
        sta     keyMask
        mov     A, C
        sta     keyColumn
        mvi     A, AUTOTIME
        sta     keyTime         ; выставляем время до следующего автонажатия
        mvi     A, 1
        sta     fPressed        ; устанавливаем флаг нажатия

  @kbInsert:     ; отправляет в буфер код нажатой клавиши
        call    kbPut
        jmp     OLDISR

  @kbRepeat:    ; уже имеется нажатая клавиша
        ; проверяем ее текущее состояние
        lda     keyColumn
        call    kbColumn
        mov     B, A
        lda     keyMask
        ana     B
        jz      @kbRelease
        ; проверяем не пора ли включать автоповтор?
        lda     keyTime
        dcr     A
        sta     keyTime
        jnz     OLDISR
        ; время ожидания истекло, заносим скан-код в буфер клавиатуры
        mvi     A, AUTOSPD
        sta     keyTime
        jmp     @kbInsert

  @kbRelease:   ; отжали клавишу
        xra     A
        sta     fPressed        ; снимаем флаг нажатия
OLDISR: ; jmp to old INT
        ret
        ret
        ret


;------------------------------------------------------------------------
; преобразование строки матрицы и бита в код клавиши и
; добавление его в буфер клавиатуры
;------------------------------------------------------------------------
; на входе:
;    keyColumn  - номер строки
;    keyMask    - крайний справа бит строки матрицы
kbPut:
        lda     keyColumn
        ani     0Fh
        rlc
        rlc
        rlc
        mov     E, A            ; E = column * 8
        lda     keyMask
        ana     A
        rz
        mvi     C, 0
    @cbclp:
        rrc
        jc      @cbcdn
        inr     C
        jmp     @cbclp
    @cbcdn:
        mov     A, C
        add     E
        ; теперь переводим сканкод в символьный вид
        mov     L, A            ; HL - скан-код клавиши
        mvi     H, 0
        lxi     D, tabXlat
        lda     fShift
        ora     A
        jz      @gtxlat
        lxi     D, tabSXlat
    @gtxlat:
        dad     D
        mov     A, M            ; A - символьный код клавиши
        ; добавляем в буфер клавиатуры
        lhld    ptrBufLast
        lxi     D, endBuffer
        mov     M, A
        inx     H
        call    CompareWord
        jnz     @kbpd
        lxi     H, keyBuffer
    @kbpd:
        shld    ptrBufLast
        ret








tabXlat:
        db ' ','!','"','#','$','%','&',27h
        db '(',')',',','-','.',':',';','?'
        db '{','|','}','~',' ','`','a','b'
        db 'c','d','e','f','g','h','i','j'
        db 'k','l','m','n','o','p','q','r'
        db 's','t','u','v','w','x','y','z'
        db 0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h
        db 0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh ; db 0B8h,0B9h,1Bh,09h,0BCh,08h,0BEh,0Dh
        db ' ',0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h
        db 0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh

tabSXlat:
        db '0','1','2','3','4','5','6','7'
        db '8','9','<','=','>','*','+','/'
        db '[','\',']','^','_','@','A','B'
        db 'C','D','E','F','G','H','I','J'
        db 'K','L','M','N','O','P','Q','R'
        db 'S','T','U','V','W','X','Y','Z'
        db 0B0h,0B1h,0B2h,0B3h,0B4h,0D5h,0D6h,0D7h
        db 0D8h,0D9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
        db ' ',0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h
        db 0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh



        dseg

  Timer_ticks:          ds 1


  Ctrl_KeyUp:           ds 1
  Ctrl_KeyLeft:         ds 1
  Ctrl_KeyRight:        ds 1
  Ctrl_KeyDown:         ds 1

  ; адрес старого обработчика прерывания
  OldVecJmp:            ds 1
  OldVecAddr:           ds 2

;------------------------------------------------------------------------
; Данные сканера
;------------------------------------------------------------------------

  fPressed:     ds 1            ; флаг наличия нажатой кнопки
  keyMask:      ds 1            ; бит нажатой клавиши
  keyColumn:    ds 1            ; строка нажатой клавиши
  keyTime:      ds 1            ; таймер для отслеживания зедержек автоповтора

  fShift:       ds 1            ; флаг нажатия РГ (shift)

  keyBuffer:    ds 8            ; буфер приема скан-кодов (на 8 мест)
  endBuffer:


  ptrBufFirst:  ds 2            ; указатель на начало буфера
  ptrBufLast:   ds 2            ; указатель на конец буфера

end
