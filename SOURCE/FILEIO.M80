$title  ('File functions')
        name    FileIO

        cseg

        public  fOpen
        public  fCreate
        public  fClose
        public  fDelete

        public  fRead
        public  fWrite

        public  fCRC




; системные переменные
CURDEV  equ 4           ; текущие диск и user
DEFFCB  equ 5Ch         ; дефолтный FCB
IOBUFF  equ 80h         ; дефолтный буфер DMA



;------------------------------------------------------------------------
; открытие файла
;------------------------------------------------------------------------
; на входе:
;    BC - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    A  - 0: ошибка открытия, иначе успешно
fOpen:
        call    MkFCB
        mvi     C, 15
        call    5
  io_return:
        cpi     0FFh
        jz      @ferror
        ori     -1
        ret
  @ferror:
        xra     A
        ret


;------------------------------------------------------------------------
; создание файла
;------------------------------------------------------------------------
; на входе:
;    BC - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    A  - 0: ошибка создания
;
; WARNING! наличие существующего файла система не проверяет, поэтому
;          нужно самому в этом удостовериться и удалить, иначе
;          будет создан дубликат с таким же именем!
fCreate:
        call    MkFCB
        mvi     C, 22
        call    5
        jmp     io_return


;------------------------------------------------------------------------
; удаление файла
;------------------------------------------------------------------------
; на входе:
;    BC - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    A  - 0: ошибка создания
fDelete:
        call    MkFCB
        mvi     C, 19
        call    5
        jmp     io_return


;------------------------------------------------------------------------
; закрывает файл
;------------------------------------------------------------------------
; на входе:
;    FCB - открытый файл
fClose:
        lxi     D, DEFFCB
        mvi     C, 16
        jmp     5



;------------------------------------------------------------------------
; чтение файла
;------------------------------------------------------------------------
; на входе:
;    BC - буфер для чтения
;    DE - размер в секторах
; на выходе:
;     A - флаг завершения: 0 - ошибка, -1 - все успешно считалось
fRead:
        ; ограничим размер файла 255 секторами (32640 bytes)
        mov     A, D
        ora     A
        rnz
        mov     A, E
        ora     A
        rz                      ; -> ошибка, нулевая длина
        ; задаем буфер DMA
        mov     E, C
        mov     D, B
        jmp     @frdsd

    @frdlp:
        ; читаем очередной сектор
        lxi     D, DEFFCB
        mvi     C, 20
        call    5
        ora     A
        jnz     @frdqf
        ; переходим к чтению следующего сектора
        pop     PSW
        pop     D               ; DE = bufAddr
        dcr     A
        jz      @frdqo
        lxi     H, 128
        dad     D
        xchg                    ; DE = bufAddr+128
    @frdsd:
        ; устанавливаем буфер DMA
        push    D
        push    PSW
        mvi     C, 26
        call    5
        jmp     @frdlp

  @frdqf:
        pop     D               ; очищаем стек
        pop     D
        xra     A
        jmp     @frdxt
  @frdqo:
        ori     -1
  @frdxt:
        push    PSW
        ; восстанавливаем дефолтный буфер DMA
        lxi     D, IOBUFF
        mvi     C, 26
        call    5
        pop     PSW
        ret


;------------------------------------------------------------------------
; запись в файл
;------------------------------------------------------------------------
; на входе:
;    BC - буфер с данными
;    DE - размер буфера в секторах
; на выходе:
;     A - флаг завершения: 0 - ошибка, -1 - все успешно записано
fWrite:
        ; ограничим размер файла 255 секторами (32640 bytes)
        mov     A, D
        ora     A
        rnz
        mov     A, E
        ora     A
        rz                      ; -> ошибка, нулевая длина
        mov     L, A            ; L - размер в секторах
        mov     E, C
        mov     D, B            ; DE - buffer

    fwrlp:
        push    H
        push    D
        ; устанавливаем новый буфер DMA
        mvi     C, 26
        call    5
        ; пишем из него очередной сектор
        lxi     D, DEFFCB
        mvi     C, 21
        call    5
        ; lpBuffer += 128
        pop     D
        lxi     H, 128
        dad     D
        xchg
        pop     H
        cpi     0FFh
        jz      fwrer           ; -> произошла ошибка
        dcr     L               ; size--
        jnz     fwrlp
        ; успешное завершение
        ori     -1
        ret

    fwrer:
        xra     A
        ret


;------------------------------------------------------------------------
; заполнение структуры FCB (по дефолтному адресу 0x005C)
;------------------------------------------------------------------------
; на входе:
;    BC - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    DE - указатель на FCB
MkFCB:

        lxi     H, DEFFCB
        push    H
        ; set disk
        lda     CURDEV
        ani     0Fh
        inr     A
        mov     M, A
        inx     H
        ; copy file name
        mvi     E, 11
  @fname:
        ldax    B
        inx     B
        mov     M, A
        inx     H
        dcr     E
        jnz     @fname
        ; обнуляем остальные поля
        mvi     E, 36-12
        xra     A
    @fffsz:
        mov     M, A
        inx     H
        dcr     E
        jnz     @fffsz
        pop     D
        ret



;------------------------------------------------------------------------
; вычисление CRC блока данных
;------------------------------------------------------------------------
; на входе:
;    BC - сектор (128 байт)
; на выходе:
;    HL - CRC 126 первых байт сектора
fCRC:
        xra     A
        mov     L, A
        mov     H, A
        mvi     E, 126
        push    PSW
    @loop:
        pop     PSW
        ldax    B
        ral
        push    PSW
        add     L
        mov     L, A
        adc     H
        mov     H, A
        inx     B
        dcr     E
        jnz     @loop
        pop     PSW
        ret


end
